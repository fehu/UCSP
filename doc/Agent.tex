%\begin{document}


% \def\lifetime    {\mathit{lifetime}}
% \def\class       {\mathit{class}}
% \def\execute     {\mathit{execute}}
% \def\decide      {\mathit{decide}}
% \def\knownClasses{\overset{\mathrm{known}}{\mathit{classes}}}


\section{Agents}

The \emph{negotiating agents} are isolated proactive computational entities,
capable of sending and receiving messages.
The \emph{isolation} denotes that agents' internal states are protected
from outside access. Messaging is the only way an agent can be interacted with.
The \emph{pro-activity} implies a capacity of acting asynchronously,
with no ``external'' cause.

\medskip

An agent is defined by it's behaviour --- the combination of its
\emph{proactive} and \emph{reactive} (message handling) functions.

Therefore two agents with same behaviour functions should be considered two instances
of the same agent. In must be noted, that all the diference in the behaviour of
two instances is produced by the differences in the states
(both agent's internal state and the environment's one).

\medskip

In order to generalize agents behaviour, agent \emph{roles} are introduced.
A role describes whom or what an agents represents in the negotiation and
defines \emph{behaviour archetype} --- the rules to build
agent's \emph{behaviour functions}, given some \emph{role-specific} knowledge.

\subsection{Agents Implementation}

Agents are implemented using \emph{Software Transactional Memory} (STM)
\cite{STMCode07} --- a promising concurrency paradigm.
They are executed in two computational threads:
one for message handling and another for proactive action.

\medskip

\noindent
Agent's behavior is flexible and may be changed during agent's lifetime.
As it was mentioned before, it is determined by \emph{message handling} and
\emph{action} functions.
Any complex behaviour would require the agent to have some \emph{mutable}
internal \emph{states}, where it could store the related information,
thus remembering it throughout behaviour executions.
The only restriction is that states interface must be fixed for type safety
(only the interface, not the underlying data).


Each agent also has two system states: the \emph{run state} and special \emph{shared
  state}, called \emph{status}. The run state controls agent's execution
(and termination), while the status is monitored by the respective controller.
Agents have three \emph{run states}: ``Paused'', ``Running'' and ``Terminate''.
The first two states should control pro-action;
setting the last one should cause all agent's processes to stop.
The \emph{status}es are further described in section \ref{agentControllers}.

\medskip

To ensure agents isolation, the direct interactions are restricted;
an agent only exposes its communication interface through \emph{agent reference}.

Using this interface, one can simply \emph{send} a message to an agent,
or one can \emph{ask} for some \emph{expected response}, corresponding to the message sent.
Agents have separate handler functions for theese two cases.

\medskip

All behavior functions
accept two arguments:
\begin{enumerate}
\item the agent's \emph{inner interface}, that provides
  control over agent's own behavior and lifetime;
\item agent's \emph{internal state}.
\end{enumerate}

\subsubsection{Negotiation}


A negotiation has a \emph{classes pool}, distributed between the agents.
A class $\left< d, g, p, r, \bar d, t, t \right>$ is known to agents,
representing $g$, $p$ and $r$.

Negotiations are organized by special kind of agents --- \emph{controllers}.

\red{TODO}


\subsubsection{Coherence-based}

\red{ They are not the same as ``Coherence-driven Agents'' from \cite{UAB-Thesis}!
      It should be properly described.
 }

A \emph{coherence-based agent} bases its decisions on existing \emph{candidates}
and their \emph{coherence}. It must contain it's contexts within the state,
define contexts order and set the splitting one. It also must provide a
\emph{decider}.
\medskip

\noindent
Such agent acts repeatedly:
\begin{enumerate}
\item Gets its \emph{classes pool}, that may be stored within some context or
  somewhere else in the state.
\item Generates the initial candidates, using the \emph{splitting context} and
  classes pool.
\item Propagates the candidates through the contexts, as described in section
  \ref{section:coherence}.
\item Passes the \emph{assessed candidates} to the \emph{decider}.
\end{enumerate}

The decider must choose between two actions:
\begin{itemize}
\item Add new class(es) to the \emph{pool}. Such decision is taken if
  none of assessed candidates is \emph{acceptable}.
\item Select best solution and wait. This should be done if a satisfying
  solution was found. The agent's \emph{run state} is set to ``Paused'' and
  the \emph{status} is updated to ``Waiting''.
\end{itemize}

\subsubsection{Classes generation}
\label{section:class-gen}
When no \emph{acceptable candidates} can be obtained by combining the classes
from the \emph{pool}, new class need to be added (to the \emph{classes pool}).

In order to avoid ``garbage'' classes generation, the newly created classes must:
\begin{enumerate}[(1)]
  \item Be \emph{capacity} consistent. The group, professor and classroom,
    assigned to the class, must be \emph{capable} of handling the assigned discipline
    (it must comply with their respective \emph{capabilities}).
  \item Not be a repetition of any of \emph{discarted classes}
    (see section \ref{section:clean-pool}).
\end{enumerate}

In order to keep track of discarted classes without keeping them around,
class \emph{hashes} may be used. The only restriction on hash function is
injectiveness:
\begin{align*}
  \forall c_1, c_2 \in \text{ \emph{classes}} & \\
  \mathrm{hash}(c_1) &= \mathrm{hash}(c_2) \implies c_1 = c_2
\end{align*}

\subsubsection{Pool cleanup}
\label{section:clean-pool}

Even with no discipline-inconsistent classes being genrated
(sec. \ref{section:class-gen} (1)), the amount of
``bad'' classes (that worsen solutions) would be growing.
Those classes need to be discarted and their \emph{hashes} guarded
to be used in \ref{section:class-gen} (2). Discarted classes hashs must be
shared between \emph{group}, \emph{professor} and \emph{classroom} agents,
corresponding to the class.

A class should be considered \emph{solution worsening} and be discarted, if
\begin{enumerate}
  \item no \emph{acceptable candidate} (after propagating through all the contexts)
    contains the class;
  \item \red{?}
\end{enumerate}


\red{TO DO}





\subsection{Controllers}

The controllers create new negotiating agents, and monitor their \emph{status}es
over their lifetimes. Controllers also provide communication references for the
agents they control. In order to facilitate references sharing, the controllers
are restricted to a single \emph{role} for it's agents.

Controllers have hierarchical structure, starting with the \emph{root
  controller}. The orders received by \emph{root} are propagated to
the underlying controllers.

\medskip

As mentioned before, negotiating agents have a special state,
called \emph{status}, that is monitored by the controllers. Apart
from receiving agents' errors, the \emph{status}es are used to
extract the \emph{distributed solution} from the agents.
This is done using ``Waiting'' and ``Locked'' statuses.

The agents set ``Waiting'' status when a suitable solution is found,
and the corresponding controller waits for all of its subjugated
agents to set it. When it is done, the controller sends ``Lock''
command to the agents and notifies the \emph{parent controller}.
When the \emph{root controller} receives ``Lock'' notifications from
all the controllers, it sends ``Collect'' order. On that order, the controllers
extract the solution parts (guarded in the statuses) and propagate them up to
the root.
