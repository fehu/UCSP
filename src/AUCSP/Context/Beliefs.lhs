
%if False
\begin{code}

module AUCSP.Context.Beliefs(

  Beliefs(..)

, TimeConsistency

)  where

import AUCSP.Classes
import AUCSP.Coherence
import AUCSP.Context

import qualified AUCSP.Context.Combine as Combine

import Data.IORef (IORef, readIORef)
import Data.Coerce (coerce)
import Data.Maybe (catMaybes)
import Data.Tuple
import qualified Data.Map as Map

import Control.Monad.Fix

\end{code}
%endif


\subsubsection{Beliefs}
The beliefs is a \emph{splitting} context, that uses as it's internal
knowledge:
\begin{enumerate*}[1)]
 \item \emph{state of the timetable}, that represents
       \emph{best} candidate, generated until now;
 \item \emph{interesting} proposals, both generated by
       agent itself and received from the others,
       that are preserved throughout agent's lifetime.
\end{enumerate*}

\bigskip\noindent
\textbf{Assessing} yields one of three values $$
\begin{cases}
 -1 & \mbox{if two proposals intersect in time} \\
  0 & \mbox{if both proposals have the same \emph{abstract} part} \\
  1 & \mbox{otherwise}
\end{cases} $$

\begin{figure}[h]
  \centering
  \input{Document/tikz/BeliefsNewProposal}
  \caption{Assessing proposal coherence, starting from \emph{Beliefs} context.}
  \label{fig:AssessBeliefs}
\end{figure}

\red{should be written in another place, not in this context}

The assessment of \emph{concrete proposals} (containing concrete classes)
in the graph consists in
\begin{enumerate}
  \item \emph{assuming} the proposal information;
  \item \emph{splitting} the assumed information graph into valid candidates;
  \item \emph{propagating} of the candidates through the rest of the contexts;
  \item comparing the \emph{best candidate} with the previous \emph{best}.
\end{enumerate}

\red{?} The proposal is called \emph{interesting} and is
accepted (and the assumed graph becomes the new information graph
of \emph{beliefs} context)
if it's assumption causes better candidate generation.
It's rejected otherwise (and the assumed graph is discarded).


\bigskip\noindent
\textbf{Splitting} is a process of extraction of \emph{acceptable} sub-graphs,
that compares the coherence values at graph's edges against a threshold.
The splitting can be achieved with one of two following strategies:
\begin{enumerate}
  \item \emph{Joining} proposals while validness is preserved.
  \item \emph{Partitioning} of proposals until validness is achieved.
\end{enumerate}

First strategy is used in this project, due to less memory consumption
(it doesn't have to generate or store big invalid graphs,
that would be present at the first steps of the second strategy).

The splitting is implemented as follows:
\begin{align*}
  \mbox{Let } & C=\lbrace c \rbrace \text{ be a set of \emph{class proposals}}.\\
            ~ & A_i=\lbrace a_i \rbrace \text{ be a set of \emph{acceptable candidates},
                                         composed of } i \text{ proposals.}\\
            ~ & A=\bigcup\limits_{i} A_i \text{ be a set of \emph{acceptable candidates}}.
\end{align*}

\begin{enumerate}
  \item Each single candidate is acceptable:
    $A_1 = \lbrace [ c ] ~||~ \forall ~ c \in C \rbrace$.
  \item Form $A_2$ by extending each candidate $[c'] = a_1 \in A_1$ with $c \in C$,
    if and only if $c'$ and $c$ do not intersect. If $A_1 \not= \emptyset$,
    then try to form $A_2$.
  \item[\vdots]
  \item[i.] Form $A_i$ by extending each candidate $[c'_1, \dots, c'_{i-1}] = a_{i-1}
    \in A_{i-1}$ with $c \in C$, if and only if $\forall c' \in a_{i-1}, ~c'$
    and $c$ do not intersect. If $A_i \not= \emptyset$, then try to form $A_{i+1}$.
   \item[\vdots]
   \item[n.] $A_n = \emptyset \implies$ all the \emph{acceptable candidates}
     were generated. Done.

\end{enumerate}

\crule{0.5}

% 'SomeTime' is removed from shown code to reduce visible expressions length
%{
%format SomeTime (x) = x
\begin{code}
data Beliefs a = Beliefs  {  knownProposals  :: IORef IGraph }

data TimeConsistency a = TimeConsistency

instance Functor TimeConsistency where fmap _ = const TimeConsistency

instance InformationRelation TimeConsistency where
  relationName _ = "TimeConsistency"
  coerceRelation = coerce

type instance RelationDetails TimeConsistency = NoDetails

instance BinaryRelation TimeConsistency where
  binRelValue _ i1 i2 = do
    Class c1  <- collectInf i1
    Class c2  <- collectInf i2

    let  sameParticipant  =   classGroup c1      ==  classGroup c2
                          ||  classProfessor c1  ==  classProfessor c2
                          ||  classRoom c1       ==  classRoom c2
         sameDay = classDay c1 == classDay c2
         timeIntersects  x y  = SomeTime (classBegins x)  <= SomeTime  (classBegins y)
                             && SomeTime (classEnds x)    >= SomeTime  (classBegins y)

         sameAbstract  =   classDiscipline c1  ==  classDiscipline c2
                       &&  classGroup c1       ==  classGroup c2
                       &&  classProfessor c1   ==  classProfessor c2
                       &&  classRoom c1        ==  classRoom c2
                       &&  classNumber c1      ==  classNumber c2

         intersect  =   sameParticipant
                    &&  sameDay
                    &&  (timeIntersects c1 c2 || timeIntersects c2 c1)

    return . swap . (,) NoDetails $ if sameAbstract  then 0
                                                     else if intersect then -1 else 1

instance (Num a) => Context Beliefs a where
  contextName _       = "Beliefs"
  contextInformation  = readIORef . knownProposals
  contextRelations _  = return [RelBin TimeConsistency]
  contextThreshold _  = return 0

  type AssessmentDetails Beliefs = NoDetails

  combineWholeRels    = Combine.wholeRelsProduct (const NoDetails)
  combineBinRels      = Combine.binRelsProduct (const NoDetails)
  combineRels         = Combine.relsProduct (\_ _ -> NoDetails)

  noAssessmentDetails _ = NoDetails


instance (Num a) => SplittingContext Beliefs a where
  splitGraph b gr = do
    iGraph <- readIORef $ knownProposals b
    let  cNodes = catMaybes $ collectInf <$> graphNodes gr
         consistent x y = fmap fst (binRelValue TimeConsistency x y) == Just 1
         extendCandidate Failure{} = []
         extendCandidate Success{candidate=inf} = do
             c <- cNodes
             [  Success{assessHistory = [], candidate = graphNodes gr ++ [c]}
                | all (consistent c) inf ]

         a1 = Success [] . (:[]) <$> cNodes

    return $ fix (\f acc last ->  let ext = concatMap extendCandidate last
                                    in  if null ext
                                        then acc
                                        else f (acc ++ ext) ext
             ) a1 a1

\end{code}
%}

